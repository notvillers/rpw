#!/bin/bash
set -e

# Default variables
length=32
repeat_count=1
use_symbols=0
lower_only=0
challenge_mode=0
numbers_only=0
must_have_number=0
must_have_char=0
must_have_symbol=0
min_length=0
out_path=""

challenge_charset="abcdef0123456789"

# POSIX-safe symbol set
symbol_charset='!@#$%^&*()_+=[]{}|;:,.<>?/~-'

print_help() {
  cat <<EOF
Usage: $(basename "$0") [options]

R(andom)P(ass)W(ord) generates a random string.

Options:
  -l <length>       Set password length (default: $length)
  -r <count>        Number of generated password(s)
  -s                Include symbols
  -c                Challenge-response charset
  -L                Use lowercase alphanumeric only
  -n                Numbers only
  -N                Must contain a digit
  -A                Must contain an alphabetic character
  -S                Must contain a symbol
  -o <file>         Append output(s) to file
  -h, --help        Show help
  --easy            Easy password
  --medium          Medium password
  --hard            Hard password
  --yubi-challenge  Yubikey challenge-response
EOF
}

set_easy() {
  length=8
  lower_only=1
}

set_medium() {
  length=16
  must_have_number=1
  must_have_char=1
}

set_hard() {
  length=32
  use_symbols=1
  must_have_number=1
  must_have_char=1
  must_have_symbol=1
}

set_yubi_challenge() {
  lower_only=1
  length=40
  challenge_mode=1
}

args=()
for arg in "$@"; do
  case "$arg" in
    --help) print_help; exit 0 ;;
    --easy) set_easy ;;
    --medium) set_medium ;;
    --hard) set_hard ;;
    --yubi-challenge) set_yubi_challenge ;;
    *) args+=("$arg") ;;
  esac
done
set -- "${args[@]}"

while getopts ":l:r:sncLNASo:h" opt; do
  case "$opt" in
    l) length="$OPTARG" ;;
    r) repeat_count="$OPTARG" ;;
    s) use_symbols=1 ;;
    n) numbers_only=1 ;;
    c) challenge_mode=1 ;;
    L) lower_only=1 ;;
    N) must_have_number=1 ;;
    A) must_have_char=1 ;;
    S) must_have_symbol=1 ;;
    o) out_path="$OPTARG" ;;
    h) print_help; exit 0 ;;
    \?) printf "Invalid option: -%s\n" "$OPTARG"; exit 1 ;;
  esac
done

# Minimum length enforcement
[ "$must_have_number" -eq 1 ] && ((min_length++))
[ "$must_have_char" -eq 1 ] && ((min_length++))
[ "$must_have_symbol" -eq 1 ] && ((min_length++))

if ! [[ "$length" =~ ^[0-9]+$ ]] || [ "$length" -lt "$min_length" ]; then
  printf "Error: invalid length\n" >&2
  exit 1
fi

if ! [[ "$repeat_count" =~ ^[0-9]+$ ]] || [ "$repeat_count" -lt 1 ]; then
  printf "Error: invalid repeat count\n" >&2
  exit 1
fi

if [[ "$numbers_only" -eq 1 && ( "$use_symbols" -eq 1 || "$challenge_mode" -eq 1 || "$min_length" -gt 0 ) ]]; then
  printf "Error: -n cannot be combined with other constraints\n" >&2
  exit 1
fi

if [[ "$challenge_mode" -eq 1 && ( "$use_symbols" -eq 1 || "$numbers_only" -eq 1 || "$min_length" -gt 0 ) ]]; then
  printf "Error: -c cannot be combined with other constraints\n" >&2
  exit 1
fi

# Charset selection
if [ "$challenge_mode" -eq 1 ]; then
  charset="$challenge_charset"
elif [ "$numbers_only" -eq 1 ]; then
  charset='0-9'
else
  if [ "$lower_only" -eq 1 ]; then
    charset='a-z0-9'
  else
    charset='A-Za-z0-9'
  fi
  [ "$use_symbols" -eq 1 ] && charset="${charset}${symbol_charset}"
fi

# Generator (length-safe)
generate_pw() {
  local pw
  pw=$(LC_ALL=C tr -dc "$charset" < /dev/urandom | head -c "$length")
  [ "${#pw}" -eq "$length" ] || return 1
  printf '%s' "$pw"
}

for ((i=0; i<repeat_count; i++)); do
  while :; do
    password=$(generate_pw) || continue
    ok=1

    [ "$must_have_number" -eq 1 ] && ! [[ "$password" =~ [0-9] ]] && ok=0
    [ "$must_have_char" -eq 1 ] && ! [[ "$password" =~ [A-Za-z] ]] && ok=0
    [ "$must_have_symbol" -eq 1 ] && ! [[ "$password" =~ [^A-Za-z0-9] ]] && ok=0

    [ "$ok" -eq 1 ] && break
  done

  if [ -n "$out_path" ]; then
    printf "%s\n" "$password" >> "$out_path"
  else
    printf "%s\n" "$password"
  fi
done
