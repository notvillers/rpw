#!/bin/bash
set -e

# Default variables
length=32 # Default length, varies by -l parameter
repeat_count=1 # Number of generated password(s)
use_symbols=0 # Sets to 1 if symbols is needed in the password
lower_only=0 # Sets to 1 if password should containt lowercase characters only
challenge_mode=0 # Sets to 1 if generation is a challenge-response
numbers_only=0 # Numbers only
must_have_number=0 # Sets to 1 if password must contain at least 1 number
must_have_char=0 # Sets to 1 if password must contain at least 1 alphanumeric character
must_have_symbol=0 # Sets to 1 if password must contain at least 1 symbol
min_length=0 # Varies by given -N, -C and -S flags
out_path="" # Out put path if given

challenge_charset="abcdef0123456789" # Charset for challenge-response
symbol_charset="!@#\$%^&*()_+-=[]{}|;:,.<>?/" # Charset for symbols

# Print help
print_help() {
  cat <<EOF
Usage: $(basename "$0") [options]

Description:
R(andom)P(ass)W(ord) generates a random string from the (pre)specified charset, default charset is [A-Za-z0-9].

Options:
  -l <length>     Set password length (default: $length)
  -r <count>      Number of generated password(s) (default: $repeat_count)
  -s              Include symbols
  -c              Challenge mode (charset: $challenge_charset)
  -L              Use lowercase alphanumeric only
  -n              Password must contain number(s) only
  -N              Password must contain a digit
  -C              Password must contain a character
  -S              Password must contain a symbol
  -o <file>       Appends output(s) to file instead of stdout
  -h, --help      Show this help message
  --easy          Sets parameters for an easy password (Can be freely combined with other available flags)
  --medium        Sets parameters for a medium password (Can be freely combined with other available flags)
  --hard          Sets parameters for a hard password (Can be freely combined with other available flags)
EOF
}

set_easy() {
  length=8
  lower_only=1
}

set_medium() {
  length=16
  must_have_number=1
  must_have_char=1
}

set_hard() {
  length=32
  use_symbols=1
  must_have_number=1
  must_have_char=1
  must_have_char=1
}

args=()
# Args
for arg in "$@"; do
  case "$arg" in
    --help)
      print_help
      exit 0
      ;;
    --easy)
      set_easy
      ;;
    --medium)
      set_medium
      ;;
    --hard)
      set_hard
      ;;
    *)
      args+=("$arg")
      ;;
  esac
done

set -- "${args[@]}"

# Options
while getopts ":l:r:sncLNCSo:h" opt; do
  case "$opt" in
    l) length="$OPTARG" ;;
    r) repeat_count="$OPTARG" ;;
    s) use_symbols=1 ;;
    n) numbers_only=1 ;;
    c) challenge_mode=1 ;;
    L) lower_only=1 ;;
    N) must_have_number=1 ;;
    C) must_have_char=1 ;;
    S) must_have_symbol=1 ;;
    o) out_path="$OPTARG" ;;
    h) print_help; exit 0 ;;
    \?) printf "Invalid option: -%s\n" "$OPTARG"; print_help; exit 1 ;;
  esac
done

# Min. length increase, if needed
if [ "$must_have_number" -ne 0 ]; then
  ((min_length++))
fi

# Min. length increase, if needed
if [ "$must_have_char" -ne 0 ]; then
  ((min_length++))
fi

# Min. length increase, if needed
if [ "$must_have_symbol" -ne 0 ]; then
  ((min_length++))
fi

# Length validate
if ! [[ "$length" =~ ^[0-9]+$ ]] || [ "$length" -lt 1 ]; then
  printf "Error: -l <length> must be a positive integer (1 or larger).\n" >&2
  exit 1
fi

# Repeat validate
if ! [[ "$repeat_count" =~ ^[0-9]+$ ]] || [ "$repeat_count" -lt 1 ]; then
  printf "Error: -r <count> must be a positive integer (1 or larger).\n" >&2
  exit 1
fi

# Numbers only combination check
if [[ "$numbers_only" -eq 1 && ( "$min_length" -gt 0 || "$use_symbols" -ne 0 || "$challenge_mode" -ne 0 ) ]] ; then
  printf "Error: Numbers only (-n) flag cannot be combined with -s, -c, -N, -C, or -S flags.\n" >&2
  exit 1
fi

# Challenge combination check
if [[ "$challenge_mode" -eq 1 && ( "$min_length" -gt 0 || "$use_symbols" -ne 0 || "$numbers_only" -ne 0 ) ]] ; then
  printf "Error: Challenge (-c) flag cannot be combined with -s, -n, -N, -C, or -S flags.\n" >&2
  exit 1
fi

# Checking min_length
if [ "$length" -lt "$min_length" ]; then
  printf "Error: Lenght (%s) is smaller than the minimum required (%s), because it must contain:\n" "$length" "$min_length" >&2
  [ "$must_have_number" -ne 0 ] && printf " - a number\n" >&2
  [ "$must_have_char" -ne 0 ] && printf " - a character\n" >&2
  [ "$must_have_symbol" -ne 0 ] && printf " - a symbol\n" >&2
  exit 1
fi

# Determine charset
if [ "$challenge_mode" -eq 1 ]; then
  charset=$challenge_charset
elif [ "$numbers_only" -eq 1 ]; then
  charset="0-9"
else
  if [ "$lower_only" -eq 1 ]; then
    charset="a-z0-9"
  else
    charset="A-Za-z0-9"
  fi

  if [ "$use_symbols" -eq 1 ] || [ "$must_have_symbol" -eq 1 ]; then
    charset="${charset}${symbol_charset}"
  fi
fi

# Password generation function
generate_pw() {
  LC_ALL=C tr -dc "$charset" < /dev/urandom | head -c "$length"
}

# Generating password with constraint checks
for (( i=0; i<repeat_count; i++ )); do
  password=""
  while :; do
    password=$(generate_pw)
    ok=1

    # Check for number, if needed
    [ "$must_have_number" -eq 1 ] && ! [[ "$password" =~ [0-9] ]] && ok=0

    # Check for alphabetic char, if needed
    [ "$must_have_char" -eq 1 ]   && ! [[ "$password" =~ [A-Za-z] ]] && ok=0

    # Check for symbol, if needed
    [ "$must_have_symbol" -eq 1 ] && ! [[ "$password" =~ [^A-Za-z0-9] ]] && ok=0

    [ "$ok" -eq 1 ] && break
  done

  if [ -n "$out_path" ]; then
    printf "%s\n" "$password" >> "$out_path"
  else
    printf "%s\n" "$password"
  fi
done
